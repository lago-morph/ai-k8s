# Context and Planning Notes - Testing Verification Tools

**Purpose**: This file preserves context from the initial planning discussion that may not be fully captured in the requirements document. Future AI agents should read this file when working on this spec.

## Original Use Case

The testing verification tools are being added to provide multiple independent ways to verify correctness during integration testing:

### Primary Use Cases

1. **Bootstrap Cluster Verification**
   - After `mk8 bootstrap create`, verify cluster state via kubectl
   - Check Crossplane pods are running
   - Verify CRDs are installed
   - Confirm cluster is healthy beyond what kind reports

2. **AWS Resource Verification**
   - Verify Crossplane MRDs have created corresponding AWS resources
   - Check EKS cluster status and configuration
   - Confirm IAM roles, VPCs, and other infrastructure exists
   - Validate resource state matches expectations

3. **Workload Cluster Verification**
   - When mk8 creates workload clusters via Crossplane
   - Verify EKS clusters are created in AWS
   - Check cluster configuration matches specification
   - Validate connectivity and access

### Why Multiple Verification Methods

**Rationale**: The more ways we can verify correctness, the higher the probability that AI-driven development will catch bugs.

**Verification Layers**:
1. mk8 CLI output (what mk8 reports)
2. kind commands (local cluster state)
3. kubectl (Kubernetes API direct access)
4. AWS CLI (AWS API direct access)

Each layer provides independent verification, catching different classes of bugs.

## Decision: CLI Tools vs MCP Servers

### Why kubectl CLI Instead of Kubernetes MCP Server

**Decision**: Use kubectl CLI directly

**Rationale**:
1. **Maturity**: kubectl is official, battle-tested, comprehensive
2. **Script Integration**: Easier to use in BATS (shell) tests
3. **Kubernetes MCP Immaturity**: K8s MCP servers are less established, limited community support
4. **No Abstraction Overhead**: Direct API access without intermediary
5. **Debugging**: Familiar tool for troubleshooting

**Trade-off Accepted**: Need to parse JSON/YAML output instead of structured MCP responses

### Why AWS CLI Instead of AWS MCP Server

**Decision**: Use AWS CLI directly

**Rationale**:
1. **Comprehensive Coverage**: AWS CLI covers all services mk8 needs
2. **Ephemeral Credentials**: Environment variables make rotation trivial
3. **Script Integration**: Works well with shell-based tests
4. **IAM Policies**: Read-only IAM policies are well-documented and straightforward
5. **Debugging**: Standard tool for AWS troubleshooting

**Trade-off Accepted**: Need to parse JSON output instead of structured MCP responses

### Future Migration Path

If Kubernetes or AWS MCP servers mature significantly, we can:
- Evaluate migration for agent-driven testing
- Keep CLI tools for shell scripts
- Use hybrid approach (MCP for agents, CLI for scripts)

## Credential Management Strategy

### Kubernetes Credentials

**Source**: Generated by mk8 commands

**Approach**:
```bash
# Bootstrap cluster
mk8 bootstrap create
# Kubeconfig at: ~/.kube/mk8-bootstrap-config (or similar)

# In tests
export KUBECONFIG=~/.kube/mk8-bootstrap-config
kubectl get pods -A

# Or explicit path
kubectl --kubeconfig=~/.kube/mk8-bootstrap-config get pods -A
```

**For Workload Clusters**:
```bash
# Crossplane creates cluster
mk8 cluster create my-cluster

# Get credentials
mk8 cluster get-kubeconfig my-cluster > /tmp/my-cluster-kubeconfig
export KUBECONFIG=/tmp/my-cluster-kubeconfig
kubectl get nodes
```

**Read-Only Access** (if needed):
```bash
# Create ServiceAccount with read-only ClusterRole
kubectl create serviceaccount test-reader
kubectl create clusterrolebinding test-reader \
  --clusterrole=view \
  --serviceaccount=default:test-reader

# Extract token and create kubeconfig
# (Details in design phase)
```

### AWS Credentials

**Source**: Ephemeral AWS accounts (4-hour lifetime)

**Approach**: Environment variables for fast rotation

```bash
# Quick credential update
export AWS_ACCESS_KEY_ID="AKIA..."
export AWS_SECRET_ACCESS_KEY="..."
export AWS_DEFAULT_REGION="us-west-2"

# Verify
aws sts get-caller-identity
```

**Helper Script** (to be created):
```bash
#!/bin/bash
# scripts/set-aws-creds.sh

read -p "AWS Access Key ID: " access_key
read -sp "AWS Secret Access Key: " secret_key
echo

export AWS_ACCESS_KEY_ID="$access_key"
export AWS_SECRET_ACCESS_KEY="$secret_key"
export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION:-us-west-2}"

echo "âœ“ AWS credentials set for this session"
echo "Region: $AWS_DEFAULT_REGION"

# Verify
aws sts get-caller-identity
```

**Alternative**: `~/.aws/credentials` with profile
```ini
[mk8-testing]
aws_access_key_id = AKIA...
aws_secret_access_key = ...
region = us-west-2
```

```bash
# Use profile
export AWS_PROFILE=mk8-testing
aws eks list-clusters
```

### GitHub Credentials

**Note**: GitHub credentials are covered in the separate `github-workflow-automation` spec.

**Approach**: Environment variable `GITHUB_TOKEN` for long-lived PAT

## Read-Only IAM Policy

### Requirements

The IAM policy must:
1. Grant only read permissions (`Describe*`, `Get*`, `List*`)
2. Cover all AWS services mk8 uses (EKS, EC2, VPC, IAM, etc.)
3. Be documented with inline comments
4. Be easy to create in ephemeral environments
5. Be testable (verify it grants needed permissions)

### Services to Cover

Based on mk8's use of Crossplane and EKS:
- **EKS**: Cluster info, node groups, add-ons
- **EC2**: Instances, VPCs, subnets, security groups, key pairs
- **IAM**: Roles, policies, instance profiles
- **CloudFormation**: Stacks (Crossplane may use)
- **Auto Scaling**: Auto scaling groups
- **Elastic Load Balancing**: Load balancers
- **CloudWatch**: Logs (for debugging)

### Creation Approach

**Decision Deferred**: Whether humans or agents create/apply the policy

**Options**:
1. **Manual Creation**: Human creates policy once per AWS account
2. **Script Creation**: Shell script creates policy automatically
3. **Terraform/CloudFormation**: IaC tool creates policy
4. **Agent Creation**: AI agent creates policy when needed

**Considerations**:
- Ephemeral accounts (4 hours) may require frequent recreation
- Policy creation requires admin permissions (chicken-and-egg)
- Testing requires verifying policy grants needed permissions

**Likely Approach**: Provide script that creates policy, human runs it

### Policy Structure

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "EKSReadOnly",
      "Effect": "Allow",
      "Action": [
        "eks:DescribeCluster",
        "eks:ListClusters",
        "eks:DescribeNodegroup",
        "eks:ListNodegroups"
      ],
      "Resource": "*"
    },
    {
      "Sid": "EC2ReadOnly",
      "Effect": "Allow",
      "Action": [
        "ec2:Describe*",
        "ec2:Get*"
      ],
      "Resource": "*"
    }
    // ... more services
  ]
}
```

**Note**: Full policy will be created in design phase with inline comments.

## Integration with mk8 Test Framework

### Current Test Structure

mk8 uses:
- **pytest** for Python unit tests
- **BATS** for shell script integration tests
- **Hypothesis** for property-based testing

### Integration Points

**BATS Tests** (shell):
```bash
# tests/integration/test_bootstrap.bats

@test "bootstrap creates cluster with Crossplane" {
  # Create cluster
  mk8 bootstrap create
  
  # Verify with kubectl
  run kubectl get pods -n crossplane-system
  [ "$status" -eq 0 ]
  [[ "$output" =~ "crossplane" ]]
  
  # Verify with AWS CLI (if applicable)
  run aws eks describe-cluster --name mk8-bootstrap
  [ "$status" -eq 0 ]
}
```

**pytest Tests** (Python):
```python
# tests/integration/test_bootstrap.py

def test_bootstrap_creates_cluster():
    # Create cluster
    result = subprocess.run(["mk8", "bootstrap", "create"], capture_output=True)
    assert result.returncode == 0
    
    # Verify with kubectl
    result = subprocess.run(
        ["kubectl", "get", "pods", "-n", "crossplane-system", "-o", "json"],
        capture_output=True
    )
    assert result.returncode == 0
    pods = json.loads(result.stdout)
    assert any("crossplane" in pod["metadata"]["name"] for pod in pods["items"])
```

### Helper Functions (To Be Designed)

**Scope Question**: How much abstraction to provide?

**Options**:
1. **Minimal**: Just document how to use kubectl/aws CLI in tests
2. **Basic Helpers**: Simple functions for common operations
3. **Full Framework**: Comprehensive verification library

**Deferred to Design Phase**: See `SCOPE-DECISIONS.md`

## Verification Patterns

### Common Verification Scenarios

1. **Cluster Exists and is Healthy**
   ```bash
   kubectl cluster-info
   kubectl get nodes
   kubectl get pods -A
   ```

2. **Crossplane is Installed**
   ```bash
   kubectl get pods -n crossplane-system
   kubectl get crds | grep crossplane
   ```

3. **EKS Cluster Exists in AWS**
   ```bash
   aws eks describe-cluster --name my-cluster
   aws eks list-nodegroups --cluster-name my-cluster
   ```

4. **Crossplane MRD Created AWS Resource**
   ```bash
   # Check MRD status
   kubectl get managed -o yaml
   
   # Check corresponding AWS resource
   aws ec2 describe-vpcs --vpc-ids vpc-xxx
   ```

5. **Resource State Matches Expectation**
   ```bash
   # Get actual state
   actual=$(aws eks describe-cluster --name my-cluster --query 'cluster.version' --output text)
   
   # Compare to expected
   expected="1.28"
   [ "$actual" = "$expected" ]
   ```

## Future Enhancements

### Potential Additions (Not in Initial Scope)

1. **Python SDK Wrappers**
   - Use boto3 for AWS verification in Python tests
   - Use kubernetes-client for K8s verification in Python tests
   - Provides better error handling and type hints

2. **Verification Helpers**
   - `verify_cluster_healthy(kubeconfig)`
   - `verify_crossplane_installed(kubeconfig)`
   - `verify_eks_cluster_exists(cluster_name)`
   - `verify_mrd_reconciled(mrd_name, namespace)`

3. **Retry Logic**
   - Resources may not be immediately available
   - Implement exponential backoff for verification
   - Configurable timeout and retry intervals

4. **Diff Reporting**
   - Compare expected vs actual state
   - Generate human-readable diff reports
   - Highlight specific mismatches

5. **CI/CD Integration**
   - Credential injection from CI secrets
   - Test result reporting
   - Artifact collection (logs, resource dumps)

## Design Phase Considerations

When moving to the design phase, address:

### Architecture Decisions

1. **Helper Function Scope**
   - How much abstraction to provide?
   - Shell functions, Python functions, or both?
   - Where to place helper code?

2. **Credential Discovery**
   - How do tests find kubeconfig?
   - How do tests verify AWS credentials are set?
   - Error messages for missing credentials?

3. **Error Handling**
   - How to handle transient failures?
   - Retry logic for resource creation delays?
   - Timeout configuration?

4. **IAM Policy Management**
   - Script to create policy?
   - How to test policy is sufficient?
   - How to update policy as mk8 evolves?

### Testing Strategy

1. **Unit Tests**
   - Test helper functions (if created)
   - Mock kubectl/aws CLI responses
   - Test error handling

2. **Integration Tests**
   - Test against real clusters
   - Test against real AWS resources
   - Test credential rotation

3. **Documentation**
   - How to set up credentials
   - How to run integration tests
   - How to troubleshoot failures

## Unresolved Questions

These questions should be addressed during requirements review and design:

1. **Helper Function Scope** (See SCOPE-DECISIONS.md)
   - Just documentation?
   - Basic helpers?
   - Full framework?

2. **IAM Policy Creation**
   - Who creates it (human or agent)?
   - How is it applied?
   - How is it tested?

3. **Credential Validation**
   - Should tests validate credentials before running?
   - What error messages for invalid credentials?
   - Should tests fail fast or retry?

4. **Resource Cleanup**
   - Should verification tools help with cleanup?
   - How to handle orphaned resources?
   - Cleanup after test failures?

5. **Multi-Cluster Testing**
   - How to test multiple clusters simultaneously?
   - How to manage multiple kubeconfigs?
   - How to avoid credential confusion?

## Related Documentation

- ADR-004: Decision to use kubectl and AWS CLI
- ADR-003: GitHub MCP server (related spec)
- `.claude/specs/prototype/`: Bootstrap implementation that will use these tools
- `AGENTS.md`: Overall agent workflow documentation
- `SCOPE-DECISIONS.md`: Deferred scope decisions for design phase

## Notes for Future Agents

When working on this spec:

1. **Read ADR-004 first** - Understand why CLI tools were chosen over MCP
2. **Review SCOPE-DECISIONS.md** - Understand deferred decisions
3. **Check prototype spec** - See how integration tests are currently structured
4. **Test incrementally** - Verify kubectl and AWS CLI work before building abstractions
5. **Consider ephemeral accounts** - Credential rotation must be simple and fast
6. **Document examples** - Include example verification patterns in design doc
7. **IAM policy is critical** - Must be comprehensive but read-only
